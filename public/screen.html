<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Game Screen</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    body {
      margin: 0;
      background: #111;
      font-family: sans-serif;
    }

    /* NEW: two-column layout */
    #layout {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 10px;
    }

    /* HUD is now a normal left column (no absolute positioning) */
    #hud {
      width: 120px;
      margin-bottom: 10px;              /* controls sidebar width */
      color: #fff;
      font-size: 14px;
    }


    #counts div {
      margin-bottom: 4px;
    }

    .hudBtn {
      display: block;
      width: 100%;
      margin-top: 8px;
      padding: 8px 0;

      border: none;
      border-radius: 4px;
      background: #555;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }

    /* Canvas sits in the right column */
    canvas {
      display: block;
      background: #222;
      border-radius: 6px;
    }
  </style>

</head>
<body>
  <div id="hud">
    <div id="counts"></div>
    <button id="startBtn" class="hudBtn">Start Race</button>
    <button id="nextMapBtn" class="hudBtn">Next Map</button>
  </div>

  <canvas id="game" width="1000" height="600"></canvas>

  <script>
    const socket = io();
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const countsDiv = document.getElementById('counts');
    const startBtn = document.getElementById('startBtn');
    const nextMapBtn = document.getElementById('nextMapBtn');

    nextMapBtn.addEventListener('click', () => {
      socket.emit('next_map');
    });


    let map = null;
    let teams = {};
    let winner = null;
    let boulders = [];
    let teamCounts = {};
    let raceStarted = false;
    
        startBtn.addEventListener('click', () => {
      socket.emit('start_race');
    });

    function updateHud() {
      // Team counters
      countsDiv.innerHTML = '';
      if (teams && teamCounts) {
        Object.values(teams).forEach(team => {
          const count = teamCounts[team.id] || 0;
          const div = document.createElement('div');
          div.textContent = `${team.name}: ${count} players`;
          div.style.color = team.color;
          countsDiv.appendChild(div);
        });
      }

      // Button appearance
      if (raceStarted) {
        startBtn.textContent = 'Race Running';
        startBtn.style.background = 'green';
      } else {
        startBtn.textContent = 'Start Race';
        startBtn.style.background = '#555';
      }
    }

    socket.on('init', data => {
      map = data.map;
      teams = data.teams;
      boulders = data.boulders || [];
      teamCounts = data.teamCounts || {};
      raceStarted = !!data.raceStarted;
      updateHud();
      draw();
    });

    socket.on('state', state => {
      map = state.map;
      teams = state.teams;
      boulders = state.boulders || [];
      winner = state.winner;
      raceStarted = !!state.raceStarted;
      teamCounts = state.teamCounts || teamCounts;

      updateHud();
      draw();
    });

    
    socket.on('map_changed', data => {
      map = data.map;
      teams = data.teams;
      raceStarted = data.raceStarted;
      teamCounts = data.teamCounts;
      winner = null;

      updateHud();   // âœ… REQUIRED
      draw();
    });


    socket.on('race_started', data => {
      teams = data.teams;
      map = data.map;
      boulders = data.boulders || [];
      raceStarted = !!data.raceStarted;
      if (data.teamCounts) {
        teamCounts = data.teamCounts;
      }
      winner = null;
      updateHud();
      draw();
    });

    socket.on('reset', data => {
      teams = data.teams;
      map = data.map;
      boulders = data.boulders || [];
      raceStarted = !!data.raceStarted;
      if (data.teamCounts) {
        teamCounts = data.teamCounts;
      }
      winner = null;
      updateHud();
      draw();
    });

    function draw() {
      if (!map) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cellW = canvas.width / map.width;
      const cellH = canvas.height / map.height;

      // grid
      ctx.strokeStyle = '#444';
      for (let x = 0; x <= map.width; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellW, 0);
        ctx.lineTo(x * cellW, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= map.height; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellH);
        ctx.lineTo(canvas.width, y * cellH);
        ctx.stroke();
      }

      // walls
      if (map.walls) {
        ctx.fillStyle = '#555';
        map.walls.forEach(w => {
          ctx.fillRect(
            w.x * cellW,
            w.y * cellH,
            cellW,
            cellH
          );
        });
      }
      
      // boulders
      if (boulders && boulders.length) {
        ctx.fillStyle = '#8b6a4f';
        boulders.forEach(b => {
          ctx.fillRect(
            b.x * cellW + cellW * 0.15,
            b.y * cellH + cellH * 0.15,
            cellW * 0.7,
            cellH * 0.7
          );
        });
      }




      // ledges
      if (map.ledges) {
        ctx.fillStyle = '#CCCCCC'; // brown-ish
        map.ledges.forEach(l => {
          ctx.fillRect(
            l.x * cellW,
            l.y * cellH,
            cellW,
            cellH
          );
        });
      }

      // hole (goal)
      ctx.fillStyle = '#2ecc71';
      ctx.beginPath();
      ctx.arc(
        (map.hole.x + 0.5) * cellW,
        (map.hole.y + 0.5) * cellH,
        Math.min(cellW, cellH) * 0.4,
        0, Math.PI * 2
      );
      ctx.fill();

      // cubes (teams)
      Object.values(teams).forEach(team => {
        ctx.fillStyle = team.color;
        ctx.fillRect(
          team.cube.x * cellW + cellW * 0.1,
          team.cube.y * cellH + cellH * 0.1,
          cellW * 0.8,
          cellH * 0.8
        );
      });

      if (winner) {
        ctx.fillStyle = 'white';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`Winner: ${winner.toUpperCase()}`, canvas.width / 2, 60);
      }
    }
  </script>
</body>
</html>
