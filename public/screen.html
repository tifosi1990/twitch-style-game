<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Game Screen</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    body {
      margin: 0;
      background: #111;
      overflow: hidden;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #222;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      color: #fff;
      font-size: 14px;
    }
    #counts div {
      margin-bottom: 4px;
    }
    #startBtn {
      margin-top: 8px;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #555;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="counts"></div>
    <button id="startBtn">Start Race</button>
  </div>

  <canvas id="game" width="800" height="480"></canvas>

  <script>
    const socket = io();
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const countsDiv = document.getElementById('counts');
    const startBtn = document.getElementById('startBtn');

    let map = null;
    let teams = {};
    let winner = null;
    let teamCounts = {};
    let raceStarted = false;

    startBtn.addEventListener('click', () => {
      socket.emit('start_race');
    });

    function updateHud() {
      // Team counters
      countsDiv.innerHTML = '';
      if (teams && teamCounts) {
        Object.values(teams).forEach(team => {
          const count = teamCounts[team.id] || 0;
          const div = document.createElement('div');
          div.textContent = `${team.name}: ${count} players`;
          div.style.color = team.color;
          countsDiv.appendChild(div);
        });
      }

      // Button appearance
      if (raceStarted) {
        startBtn.textContent = 'Race Running';
        startBtn.style.background = 'green';
      } else {
        startBtn.textContent = 'Start Race';
        startBtn.style.background = '#555';
      }
    }

    socket.on('init', data => {
      map = data.map;
      teams = data.teams;
      teamCounts = data.teamCounts || {};
      raceStarted = !!data.raceStarted;
      updateHud();
      draw();
    });

    socket.on('state', state => {
      map = state.map;
      teams = state.teams;
      winner = state.winner;
      raceStarted = !!state.raceStarted;
      if (state.teamCounts) {
        teamCounts = state.teamCounts;
      }
      updateHud();
      draw();
    });

    socket.on('race_started', data => {
      teams = data.teams;
      map = data.map;
      raceStarted = !!data.raceStarted;
      if (data.teamCounts) {
        teamCounts = data.teamCounts;
      }
      winner = null;
      updateHud();
      draw();
    });

    socket.on('reset', data => {
      teams = data.teams;
      map = data.map;
      raceStarted = !!data.raceStarted;
      if (data.teamCounts) {
        teamCounts = data.teamCounts;
      }
      winner = null;
      updateHud();
      draw();
    });

    function draw() {
      if (!map) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cellW = canvas.width / map.width;
      const cellH = canvas.height / map.height;

      // grid
      ctx.strokeStyle = '#444';
      for (let x = 0; x <= map.width; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellW, 0);
        ctx.lineTo(x * cellW, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= map.height; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellH);
        ctx.lineTo(canvas.width, y * cellH);
        ctx.stroke();
      }

      // walls
      if (map.walls) {
        ctx.fillStyle = '#555';
        map.walls.forEach(w => {
          ctx.fillRect(
            w.x * cellW,
            w.y * cellH,
            cellW,
            cellH
          );
        });
      }
      
      // ledges
      if (map.ledges) {
        ctx.fillStyle = '#CCCCCC'; // brown-ish
        map.ledges.forEach(l => {
          ctx.fillRect(
            l.x * cellW,
            l.y * cellH,
            cellW,
            cellH
          );
        });
      }

      // hole (goal)
      ctx.fillStyle = '#2ecc71';
      ctx.beginPath();
      ctx.arc(
        (map.hole.x + 0.5) * cellW,
        (map.hole.y + 0.5) * cellH,
        Math.min(cellW, cellH) * 0.4,
        0, Math.PI * 2
      );
      ctx.fill();

      // cubes (teams)
      Object.values(teams).forEach(team => {
        ctx.fillStyle = team.color;
        ctx.fillRect(
          team.cube.x * cellW + cellW * 0.1,
          team.cube.y * cellH + cellH * 0.1,
          cellW * 0.8,
          cellH * 0.8
        );
      });

      if (winner) {
        ctx.fillStyle = 'white';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`Winner: ${winner.toUpperCase()}`, canvas.width / 2, 60);
      }
    }
  </script>
</body>
</html>
